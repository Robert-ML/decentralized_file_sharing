// SPDX-License-Identifier: MIT

pragma solidity >=0.8.28;

import "./datamodel.sol";
import "./crypto_datamodel.sol";

contract Algo3SimpleEncryption {
    PendingRegistrations private pending_registrations;

    RegisteredFileOwnerTracker private file_owners;

    StoredFiles private stored_files;

    PendingShare private share_reqs;

    FilesShared private shared_files;

// ----------------------------------------------------------------------------
// Access Methods to request registration
// ----------------------------------------------------------------------------
    function request_registration(address user) public {
        /**
         * Clients transact this method to request to register in the smart contract. That means to have a public key
         * associated with their address, the secret key paired with it being known only by the DPCN.
         *
         * @param user: the client's public ERC20 address
         */
        require(pending_registrations.pending_addresses[user] == false, "User is already pending registration");
        require(file_owners.registered[user] == false, "User is already registered");

        pending_registrations.pending_addresses[user] = true;
        pending_registrations.addresses.push(user);
        pending_registrations.address_index[user] = pending_registrations.addresses.length - 1;
    }


    function get_users_pending_registration() public view returns (address[] memory) {
        /**
         * DPCN Algo 3 calls this method periodically to check if there are users which want to register.
         *
         * @return: the pending users' addresses
         */
        return pending_registrations.addresses;
    }


    function respond_with_registration(
        address user,
        uint dpcn_pk
    ) public {
        /**
         * DPCN Algo 3 transacts this method to respond with the file owner's registration.
         * @param user: the user that initiated the register request
         * @param dpcn_pk: public key for which the private key is known only by the DPCN
         */

        // check if request exists
        require(pending_registrations.pending_addresses[user] == true, "The user is not pending registration");

        // store the data
        file_owners.registered[user] = true;
        file_owners.dpcn_pks[user] = dpcn_pk;

        // clear the request
        delete pending_registrations.pending_addresses[user];

        // if it is not the only remaining entry in the array, overwrite it with the last entry
        if (pending_registrations.addresses.length != 1) {
            // get the moved address
            address last_entry = pending_registrations.addresses[pending_registrations.addresses.length - 1];
            // move (overwrite) the last entry to the one we want to delete
            pending_registrations.addresses[pending_registrations.address_index[user]] = last_entry;
            // update the moved entry's index
            pending_registrations.address_index[last_entry] = pending_registrations.address_index[user];
        }
        // delete the last entry
        pending_registrations.addresses.pop();
        // delete the index
        delete pending_registrations.address_index[user];
    }


    function check_if_registered(address user) public view returns (bool) {
        return file_owners.registered[user];
    }


    function get_file_owner_dpcn_address(address user) public view returns (uint) {
        require(file_owners.registered[user], "The user is not registered");
        return file_owners.dpcn_pks[user];
    }


// ----------------------------------------------------------------------------
// Access Methods to upload file
// ----------------------------------------------------------------------------
    function upload_file(
        address owner,
        uint file_id,
        string memory file_info,
        string memory file_address,
        uint owner_accessible_sym_key,
        uint dpcn_accessible_sym_key
    ) public {
        /**
         * @dev Clients transact this method to upload a file's cyphertext and some metadata about it.
         *
         * @param owner: the user which initiated the file upload request
         * @param file_id: the file id of the credentials generated by the DPCN
         * @param file_info: metadata to be kept alongside the file
         * @param file_address: should be any string that helps for the encrypted file to be found as a resource
         * @param owner_accessible_sym_key: the encrypted symmetric key used to encrypt the file under the public key of the owner
         * @param dpcn_accessible_sym_key: the encrypted symmetric key used to encrypt the file  under the public key of the DPCN
         */
        require(stored_files.used_file_ids[file_id] == false, "File ID already used");

        EncryptedSymmetricKey memory container_owner_accessible_sym_key = EncryptedSymmetricKey({
            cyphertext: owner_accessible_sym_key
        });
                EncryptedSymmetricKey memory container_dpcn_accessible_sym_key = EncryptedSymmetricKey({
            cyphertext: dpcn_accessible_sym_key
        });

        FileUploaded memory file = FileUploaded({
            file_id: file_id,
            owner: owner,
            file_info: file_info,
            file_address: file_address,
            owner_accessible_sym_key: container_owner_accessible_sym_key,
            dpcn_accessible_sym_key: container_dpcn_accessible_sym_key
        });

        stored_files.file_id_data[file_id] = file;
        stored_files.used_file_ids[file_id] = true;
    }


// ----------------------------------------------------------------------------
// Access Methods to request file share
// ----------------------------------------------------------------------------

    function request_file_share(address client, uint file_id) public {
        /**
         * Clients who want a file to be shared to them transact this function to start the sharing process.
         *
         * @param client: address of the client who wants the file shared
         * @param file_id: unique identifier of the file that we want to be shared
         */
        // check the file actually exists
        require(stored_files.used_file_ids[file_id] == true, "File ID does not reference an uploaded file.");
        // check the file is not already requested
        require(share_reqs.client_file_requested[client][file_id] == false, "File was already requested by the client.");
        // check the file was not already shared
        require(shared_files.files[client][file_id] == false, "File was already shared to the client.");

        ClientShareRequest memory share_request = ClientShareRequest({
            client: client,
            file_id: file_id
        });

        share_reqs.requests.push(share_request);
        share_reqs.client_file_requests_index[client][file_id] = share_reqs.requests.length - 1;
        share_reqs.client_file_requested[client][file_id] = true;
    }

    function get_pending_share_requests() public view returns (address[] memory, uint[] memory) {
        /**
         * DPCN Algo 3 calls this method periodically to check what file share requests are pending in the EVM.
         *
         * @return: lists of elements that construct the individual requests
         * - client address (1 entry)
         * - file id (1 entry)
         *
         * Example: for 2 requests, the sizes of the returned array sizes are: (2, 2)
         */

        uint no_pending_share_reqs = share_reqs.requests.length;
        address[] memory ret_client_addresses = new address[](no_pending_share_reqs);
        uint[] memory ret_file_ids = new uint[](no_pending_share_reqs);

        for (uint i = 0; i < no_pending_share_reqs; ++i) {
            ret_client_addresses[i] = share_reqs.requests[i].client;
            ret_file_ids[i] = share_reqs.requests[i].file_id;
        }

        return (ret_client_addresses, ret_file_ids);
    }

    function respond_with_client_encrypted_sym_key(
        address client,
        uint file_id,
        uint client_accessible_sym_key
    ) public {
        /**
         * DPCN Algo 3 transacts this method to respond with the encrypted symmetric key used to encrypt the file.
         * The key is accessible using the client's private key.
         *
         * @param client: address of the client who wants the file shared
         * @param file_id: unique identifier of the file was requested to be shared
         * @param client_accessible_sym_key: the encrypted symmetric key used to encrypt the file under the public key of the client requesting the sharing
         */
        require(share_reqs.client_file_requested[client][file_id] == true, "Client did not request sharing of the file.");

        // construct the objects to store
        EncryptedSymmetricKey memory container_client_accessible_sym_key = EncryptedSymmetricKey({
            cyphertext: client_accessible_sym_key
        });

        SharedFileInfo memory shared_file = SharedFileInfo({
            file_id: file_id,
            client: client,
            client_accessible_sym_key: container_client_accessible_sym_key
        });

        // store the shared file
        shared_files.clients[client][file_id] = shared_file;
        shared_files.files[client][file_id] = true;

        // remove the share request
        delete share_reqs.client_file_requested[client][file_id];

        // if it is not the only remaining entry in the array, overwrite it with the last entry
        if (share_reqs.requests.length != 1) {
            // get the entry on the array's last position
            ClientShareRequest memory last_entry = share_reqs.requests[share_reqs.requests.length - 1];
            // move (overwrite) the entry we want to delete with the last
            share_reqs.requests[share_reqs.client_file_requests_index[client][file_id]] = last_entry;
            // update the moved entry's index
            share_reqs.client_file_requests_index[last_entry.client][last_entry.file_id] = share_reqs.client_file_requests_index[client][file_id];
        }
        // delete the last entry
        share_reqs.requests.pop();
        // delete the index
        delete share_reqs.client_file_requests_index[client][file_id];
    }

    function get_file_share_result(address client, uint file_id) public view returns (bool, uint client_accessible_sym_key) {
        /**
         * Method to be called to obtain the symmetric key for the file if s share request was submitted and processed.
         *
         * @param client: the client that initiated the file share request
         * @param field_id: the id of the file which was shared
         *
         * @return: a tuple of the call result, the first element is a bool representing if the call succeeded and the
         * second is the encrypted (for the client) symmetric key (valid only if the call succeeded)
         */
        // the file was not shared for this user
        if (shared_files.files[client][file_id] != true) {
            return (false, client_accessible_sym_key);
        }

        SharedFileInfo memory shared_file = shared_files.clients[client][file_id];
        client_accessible_sym_key = shared_file.client_accessible_sym_key.cyphertext;

        return (true, client_accessible_sym_key);
    }

// ----------------------------------------------------------------------------
// Constructor
// ----------------------------------------------------------------------------
    constructor () {}
}
